uniform float4x4 ViewProj;
uniform texture2d image;
uniform float image_width;
uniform float image_height;
uniform texture2d nine_patch;
uniform float2 nine_patch_size;
uniform float4 margin_bounds;
uniform float4 padding_bounds;

sampler_state textureSampler {
	Filter    = Linear;
	AddressU  = Clamp;
	AddressV  = Clamp;
};

struct VertDataIn {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

struct VertDataOut {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

// just return the same vertex data
VertDataOut VSDefault(VertDataIn v_in)
{
	VertDataOut vert_out;
	vert_out.uv = v_in.uv;
	vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	return vert_out;
}


// original code stolen from godot
// https://github.com/godotengine/godot/blob/7478f468b2a2fd107a610575c5a6ffed340f0d53/drivers/gles3/shaders/canvas.glsl
// map pixel coordinates to where they should be grabbed from on the n slice texture
float map_ninepatch_axis(float pixel, float draw_size, float tex_size, float margin_begin, float margin_end, inout int draw_center) {

    if (pixel < margin_begin) {
        return pixel + 1;
    } else if (pixel > draw_size - margin_end) {
        return (tex_size - (draw_size - pixel)) - 1;
    } else {
            draw_center--;

            float ratio = (pixel - margin_begin) / (draw_size - margin_begin - margin_end);
            //scale to source texture
            return (margin_begin + ratio * (tex_size - margin_begin - margin_end));
    }
}

// return if the current position falls in a content bound
int map_exclude(float pixel, float draw_size, float tex_size, float margin_begin, float margin_end) {
    if (pixel > margin_begin && pixel <= draw_size - margin_end) {
        return 1;
    }

    return 0;
}

float4 nine(VertDataOut v_in) : TARGET
{
    // Get the pixel from the source texture
    float4 currentPixel = image.Sample(textureSampler, v_in.uv);

    int draw_center = 2;

    // get the remapped position to the nine patch image
    float2 pos  = float2(
        map_ninepatch_axis(v_in.uv.x * image_width, image_width, nine_patch_size.x, margin_bounds.x, margin_bounds.z, draw_center),
        map_ninepatch_axis(v_in.uv.y * image_height, image_height, nine_patch_size.y, margin_bounds.y, margin_bounds.w, draw_center));

    // Convert position back from pixel space to uv space
    pos.xy /= nine_patch_size.xy;

    // see if we should render content
    int remove_center =
        map_exclude(v_in.uv.x * image_width, image_width, nine_patch_size.x, padding_bounds.x, padding_bounds.z)
        + map_exclude(v_in.uv.y * image_height, image_height, nine_patch_size.y, padding_bounds.y, padding_bounds.w);

    float4 patchPixel = nine_patch.Sample(textureSampler, pos);

    // Can be used for more agressive exclusion later
    if (draw_center == 0) {
        patchPixel.a = 0.0;
    }

    if (remove_center == 2) {
        // just return the current pixel data since this is in the content bounds
    } else {
        currentPixel.rgb = lerp(currentPixel.rgb, patchPixel.rgb, patchPixel.a);
        currentPixel.a = patchPixel.a;
    }

    return currentPixel;
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = nine(v_in);
	}
}
